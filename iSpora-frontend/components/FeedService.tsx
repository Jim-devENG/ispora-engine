import { useState, useEffect, useContext, createContext } from 'react';

// API base URL
const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://ispora-backend.onrender.com/api';

// Real-time feed service using backend API
const fetchFeedItems = async (page = 1, limit = 20) => {
  try {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    const devKey = localStorage.getItem('devKey');
    const token = localStorage.getItem('token');
    if (devKey) headers['X-Dev-Key'] = devKey;
    if (token) headers['Authorization'] = `Bearer ${token}`;

    const response = await fetch(`${API_BASE_URL}/feed?page=${page}&limit=${limit}&realtime=true`, {
      method: 'GET',
      headers,
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return {
      items: data.success ? data.data : [],
      realtime: data.realtime || {},
      pagination: data.pagination || {},
    };
  } catch (error) {
    console.error('Failed to fetch feed items:', error);
    return { items: [], realtime: {}, pagination: {} };
  }
};

// Real-time feed updates using Server-Sent Events
const createRealtimeConnection = (onUpdate: (update: any) => void) => {
  const token = localStorage.getItem('token');
  const devKey = localStorage.getItem('devKey');
  
  // Build URL with token as query parameter since EventSource doesn't support headers
  const url = new URL(`${API_BASE_URL}/feed/stream`);
  if (token) url.searchParams.set('token', token);
  if (devKey) url.searchParams.set('devKey', devKey);

  const eventSource = new EventSource(url.toString());

  eventSource.onmessage = (event) => {
    try {
      const update = JSON.parse(event.data);
      onUpdate(update);
    } catch (error) {
      console.error('Failed to parse realtime update:', error);
    }
  };

  eventSource.onerror = (error) => {
    console.error('Realtime connection error:', error);
    // Attempt to reconnect after 5 seconds
    setTimeout(() => {
      if (eventSource.readyState === EventSource.CLOSED) {
        createRealtimeConnection(onUpdate);
      }
    }, 5000);
  };

  return eventSource;
};

// Track user activity
const trackUserActivity = async (activity: string, metadata: any = {}) => {
  try {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    const devKey = localStorage.getItem('devKey');
    const token = localStorage.getItem('token');
    if (devKey) headers['X-Dev-Key'] = devKey;
    if (token) headers['Authorization'] = `Bearer ${token}`;

    await fetch(`${API_BASE_URL}/feed/activity`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ activity, metadata }),
    });
  } catch (error) {
    console.error('Failed to track activity:', error);
  }
};

// Get live sessions data
const fetchLiveSessions = async () => {
  try {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };
    const devKey = localStorage.getItem('devKey');
    const token = localStorage.getItem('token');
    if (devKey) headers['X-Dev-Key'] = devKey;
    if (token) headers['Authorization'] = `Bearer ${token}`;

    const response = await fetch(`${API_BASE_URL}/feed/sessions`, {
      method: 'GET',
      headers,
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data.success ? data.data : { live: [], upcoming: [], activeUsers: 0 };
  } catch (error) {
    console.error('Failed to fetch live sessions:', error);
    return { live: [], upcoming: [], activeUsers: 0 };
  }
};

// Feed item interfaces
interface FeedItem {
  id: string;
  type:
    | 'project'
    | 'opportunity'
    | 'mentorship'
    | 'success_story'
    | 'milestone'
    | 'live_event'
    | 'announcement';
  title: string;
  description: string;
  timestamp: string;
  likes: number;
  location: string;
  category: string;
  urgent?: boolean;
  deadline?: string;
  isLive?: boolean;
  isPinned?: boolean;
  isAdminCurated?: boolean;
  authorId: string;
  authorName: string;
  authorAvatar?: string;
  projectId?: string;
  opportunityId?: string;
  metadata?: Record<string, any>;
  visibility: 'public' | 'authenticated' | 'private';
  significance: 'low' | 'medium' | 'high' | 'critical';
  isAutoGenerated?: boolean;
}

interface UserAction {
  id: string;
  userId: string;
  userName: string;
  userLocation: string;
  actionType: string;
  entityId: string;
  entityType: string;
  entityName: string;
  timestamp: string;
  metadata?: Record<string, any>;
}

interface AdminHighlight {
  id: string;
  title: string;
  description: string;
  type: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  expiresAt?: string;
  createdAt: string;
  createdBy: string;
}

// Significance level mapping for auto-generation
const SIGNIFICANCE_MAP: Record<string, 'low' | 'medium' | 'high' | 'critical'> = {
  project_created: 'high',
  project_joined: 'low',
  project_completed: 'high',
  campaign_launched: 'high',
  campaign_joined: 'low',
  milestone_achieved: 'medium',
  opportunity_posted: 'medium',
  opportunity_applied: 'low',
  funding_received: 'critical',
  session_started: 'medium',
  session_completed: 'low',
  certification_earned: 'medium',
  achievement_unlocked: 'medium',
  collaboration_started: 'medium',
  mentor_match: 'low',
  workspace_created: 'low',
};

export class FeedService {
  private static instance: FeedService;
  private feedItems: FeedItem[] = [];
  private adminHighlights: AdminHighlight[] = [];
  private userActions: UserAction[] = [];
  private subscribers: Array<() => void> = [];
  private realtimeConnection: EventSource | null = null;
  private realtimeData: any = {};
  private liveSessions: any[] = [];
  private isConnected = false;

  public static getInstance(): FeedService {
    if (!FeedService.instance) {
      FeedService.instance = new FeedService();
    }
    return FeedService.instance;
  }

  // Subscribe to feed updates
  public subscribe(callback: () => void): () => void {
    this.subscribers.push(callback);
    return () => {
      this.subscribers = this.subscribers.filter((sub) => sub !== callback);
    };
  }

  private notifySubscribers(): void {
    this.subscribers.forEach((callback) => callback());
  }

  // Connect to real-time updates
  public connectRealtime(): void {
    if (this.isConnected) return;

    this.realtimeConnection = createRealtimeConnection((update) => {
      this.handleRealtimeUpdate(update);
    });

    this.isConnected = true;
    this.notifySubscribers();
  }

  // Disconnect from real-time updates
  public disconnectRealtime(): void {
    if (this.realtimeConnection) {
      this.realtimeConnection.close();
      this.realtimeConnection = null;
    }
    this.isConnected = false;
    this.notifySubscribers();
  }

  // Handle real-time updates
  private handleRealtimeUpdate(update: any): void {
    switch (update.type) {
      case 'connection':
        console.log('Connected to real-time feed:', update);
        break;
      case 'heartbeat':
        this.realtimeData = {
          ...this.realtimeData,
          activeUsers: update.activeUsers,
          lastHeartbeat: update.timestamp,
        };
        break;
      case 'user_activity':
        this.realtimeData = {
          ...this.realtimeData,
          activeUsers: update.activeUsers || this.realtimeData.activeUsers,
          lastActivity: update.timestamp,
        };
        break;
      case 'feed_update':
        // Handle new feed items
        if (update.feedItem) {
          this.addFeedItem(update.feedItem);
        }
        break;
      default:
        console.log('Unknown realtime update:', update);
    }
    this.notifySubscribers();
  }

  // Get real-time data
  public getRealtimeData(): any {
    return this.realtimeData;
  }

  // Get live sessions
  public async getLiveSessions(): Promise<any> {
    try {
      const data = await fetchLiveSessions();
      this.liveSessions = data.live || [];
      this.realtimeData = {
        ...this.realtimeData,
        activeUsers: data.activeUsers,
        liveSessions: data.live,
        upcomingSessions: data.upcoming,
      };
      this.notifySubscribers();
      return data;
    } catch (error) {
      console.error('Failed to get live sessions:', error);
      return { live: [], upcoming: [], activeUsers: 0 };
    }
  }

  // Track user activity
  public async trackActivity(activity: string, metadata: any = {}): Promise<void> {
    try {
      await trackUserActivity(activity, metadata);
    } catch (error) {
      console.error('Failed to track activity:', error);
    }
  }

  // Track user actions and generate feed items
  public trackUserAction(action: UserAction): void {
    this.userActions.push(action);
    const feedItem = this.generateFeedItemFromAction(action);
    if (feedItem) {
      this.addFeedItem(feedItem);
    }
  }

  // Add a feed item
  public addFeedItem(item: FeedItem): void {
    this.feedItems.unshift(item);
    this.notifySubscribers();
  }

  // Remove a feed item
  public removeFeedItem(itemId: string): void {
    this.feedItems = this.feedItems.filter((item) => item.id !== itemId);
    this.notifySubscribers();
  }

  // Update a feed item
  public updateFeedItem(itemId: string, updates: Partial<FeedItem>): void {
    const index = this.feedItems.findIndex((item) => item.id === itemId);
    if (index !== -1) {
      this.feedItems[index] = { ...this.feedItems[index], ...updates };
      this.notifySubscribers();
    }
  }

  // Get all feed items with filtering options
  public getFeedItems(
    options: {
      includeAdminHighlights?: boolean;
      userFilter?: string;
      categoryFilter?: string;
      significanceFilter?: 'all' | 'low' | 'medium' | 'high' | 'critical';
      limit?: number;
      visibility?: 'all' | 'public' | 'authenticated';
      includeExpired?: boolean;
    } = {},
  ): FeedItem[] {
    const {
      includeAdminHighlights = true,
      userFilter,
      categoryFilter,
      significanceFilter = 'all',
      limit,
      visibility = 'all',
      includeExpired = true,
    } = options;

    // Use only real feed items from API (no mock data generation)
    let feedItems = [...this.feedItems];

    // Filter by visibility
    if (visibility !== 'all') {
      feedItems = feedItems.filter((item) => {
        if (visibility === 'public') {
          return item.visibility === 'public';
        }
        return item.visibility === 'public' || item.visibility === 'authenticated';
      });
    }

    // Filter expired highlights
    if (!includeExpired) {
      feedItems = feedItems.filter((item) => {
        if (item.isAdminCurated && item.metadata?.expiresAt) {
          return new Date(item.metadata.expiresAt) > new Date();
        }
        return true;
      });
    }

    // Filter admin highlights
    if (!includeAdminHighlights) {
      feedItems = feedItems.filter((item) => !item.isAdminCurated);
    }

    // Filter by significance
    if (significanceFilter !== 'all') {
      const significanceLevels = ['low', 'medium', 'high', 'critical'];
      const minLevel = significanceLevels.indexOf(significanceFilter);
      feedItems = feedItems.filter((item) => {
        const itemLevel = significanceLevels.indexOf(item.significance);
        return itemLevel >= minLevel;
      });
    }

    // Apply search filters
    if (userFilter) {
      feedItems = feedItems.filter(
        (item) =>
          item.authorName?.toLowerCase().includes(userFilter.toLowerCase()) ||
          item.title.toLowerCase().includes(userFilter.toLowerCase()) ||
          item.description?.toLowerCase().includes(userFilter.toLowerCase()),
      );
    }

    if (categoryFilter) {
      feedItems = feedItems.filter((item) =>
        item.category?.toLowerCase().includes(categoryFilter.toLowerCase()),
      );
    }

    // Remove duplicates based on ID
    const uniqueItems = feedItems.filter(
      (item, index, self) => index === self.findIndex((t) => t.id === item.id),
    );

    // Sort by priority (pinned first, then by timestamp)
    uniqueItems.sort((a, b) => {
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      return b.timestamp.localeCompare(a.timestamp);
    });

    // Apply limit
    if (limit) {
      return uniqueItems.slice(0, limit);
    }

    return uniqueItems;
  }

  // Get feed statistics
  public getFeedStats(): {
    totalItems: number;
    adminHighlights: number;
    userGenerated: number;
    publicItems: number;
    liveEvents: number;
    recentActivity: number;
  } {
    const allItems = this.getFeedItems();

    return {
      totalItems: allItems.length,
      adminHighlights: allItems.filter((item) => item.isAdminCurated).length,
      userGenerated: allItems.filter((item) => !item.isAutoGenerated).length,
      publicItems: allItems.filter((item) => item.visibility === 'public').length,
      liveEvents: allItems.filter((item) => item.isLive).length,
      recentActivity: allItems.filter((item) => {
        const itemDate = new Date(item.timestamp);
        const now = new Date();
        const diffHours = (now.getTime() - itemDate.getTime()) / (1000 * 60 * 60);
        return diffHours <= 24;
      }).length,
    };
  }

  // Generate feed item from user action
  private generateFeedItemFromAction(action: UserAction): FeedItem | null {
    const significance = SIGNIFICANCE_MAP[action.actionType] || 'medium';

    switch (action.actionType) {
      case 'project_created':
        return {
          id: `action_${action.id}`,
          type: 'project',
          title: `New Project: ${action.entityName}`,
          description: `${action.userName} created a new project in ${action.userLocation}`,
          timestamp: action.timestamp,
          likes: 0,
          location: action.userLocation,
          category: 'Project',
          authorId: action.userId,
          authorName: action.userName,
          projectId: action.entityId,
          visibility: 'public',
          significance,
          isAutoGenerated: true,
        };

      case 'project_completed':
        return {
          id: `action_${action.id}`,
          type: 'success_story',
          title: `Project Completed: ${action.entityName}`,
          description: `${action.userName} successfully completed their project`,
          timestamp: action.timestamp,
          likes: 0,
          location: action.userLocation,
          category: 'Success',
          authorId: action.userId,
          authorName: action.userName,
          projectId: action.entityId,
          visibility: 'public',
          significance,
          isAutoGenerated: true,
        };

      case 'opportunity_posted':
        return {
          id: `action_${action.id}`,
          type: 'opportunity',
          title: `New Opportunity: ${action.entityName}`,
          description: `${action.userName} posted a new opportunity`,
          timestamp: action.timestamp,
          likes: 0,
          location: action.userLocation,
          category: 'Opportunity',
          authorId: action.userId,
          authorName: action.userName,
          opportunityId: action.entityId,
          visibility: 'public',
          significance,
          isAutoGenerated: true,
        };

      default:
        return null;
    }
  }

  // Mock data generation methods removed - now using real API data only

  // Helper function to check if deadline is urgent (within 7 days)
  private isDeadlineUrgent(deadline: string): boolean {
    const deadlineDate = new Date(deadline);
    const now = new Date();
    const diffDays = Math.ceil((deadlineDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    return diffDays <= 7 && diffDays > 0;
  }

  // Helper function to format timestamps
  private formatTimestamp(date: Date): string {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    if (diffHours < 1) {
      const diffMinutes = Math.floor(diffMs / (1000 * 60));
      return `${diffMinutes}m ago`;
    } else if (diffHours < 24) {
      return `${diffHours}h ago`;
    } else if (diffDays < 7) {
      return `${diffDays}d ago`;
    } else {
      return date.toLocaleDateString();
    }
  }

  // Helper function to format deadline for display
  private formatDeadline(deadline: string): string {
    const deadlineDate = new Date(deadline);
    const now = new Date();
    const diffDays = Math.ceil((deadlineDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

    if (diffDays <= 0) return 'Deadline passed';
    if (diffDays === 1) return 'Due tomorrow';
    if (diffDays <= 7) return `Due in ${diffDays} days`;

    // Format as DD/MM/YYYY
    const day = deadlineDate.getDate().toString().padStart(2, '0');
    const month = (deadlineDate.getMonth() + 1).toString().padStart(2, '0');
    const year = deadlineDate.getFullYear();
    return `Due ${day}/${month}/${year}`;
  }

  // Record a user action and automatically generate feed item
  public recordUserAction(action: UserAction): FeedItem | null {
    this.userActions.push(action);

    const feedItem = this.generateFeedItemFromAction(action);
    if (feedItem) {
      this.addFeedItem(feedItem);
      this.notifySubscribers();
    }

    return feedItem;
  }

  // Create admin highlight
  public createAdminHighlight(highlight: Omit<AdminHighlight, 'id' | 'createdAt'>): AdminHighlight {
    const newHighlight: AdminHighlight = {
      ...highlight,
      id: `highlight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString(),
    };

    this.adminHighlights.push(newHighlight);
    this.notifySubscribers();

    return newHighlight;
  }

  // Initialize with real data (no mock data)
  public initializeRealData(): void {
    // Clear any existing mock data
    this.feedItems = [];
    this.adminHighlights = [];
    this.userActions = [];
    this.notifySubscribers();
  }

  // Clear all data (for testing)
  public clearAll(): void {
    this.feedItems = [];
    this.adminHighlights = [];
    this.userActions = [];
    this.notifySubscribers();
  }
}

// React Context for Feed Service
const FeedContext = createContext<FeedService | null>(null);

export function FeedProvider({ children }: { children: React.ReactNode }) {
  const [feedService] = useState(() => {
    const service = FeedService.getInstance();
    service.initializeRealData();
    return service;
  });

  return <FeedContext.Provider value={feedService}>{children}</FeedContext.Provider>;
}

// React Hook for using Feed Service
export function useFeedService() {
  const feedService = useContext(FeedContext) || FeedService.getInstance();
  const [feedItems, setFeedItems] = useState<FeedItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [realtimeData, setRealtimeData] = useState<any>({});
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    // Load real-time data from API
    const loadFeedData = async () => {
      setLoading(true);
      try {
        const result = await fetchFeedItems(1, 50);
        if (result.items.length > 0) {
          // Use real data from backend
          setFeedItems(result.items);
          setRealtimeData(result.realtime || {});
        } else {
          // If no real data, show empty feed
          setFeedItems([]);
        }
      } catch (error) {
        console.error('Failed to load feed data:', error);
        // On error, show empty feed instead of mock data
        setFeedItems([]);
      } finally {
        setLoading(false);
      }
    };

    loadFeedData();

    // Connect to real-time updates
    feedService.connectRealtime();
    setIsConnected(true);

    // Load live sessions
    feedService.getLiveSessions();

    // Subscribe to feed service updates
    const unsubscribe = feedService.subscribe(() => {
      setFeedItems([...feedService.feedItems]);
      setRealtimeData(feedService.getRealtimeData());
      setIsConnected(feedService.isConnected);
    });

    // Track user activity
    feedService.trackActivity('viewing_feed', { timestamp: new Date().toISOString() });

    return () => {
      unsubscribe();
      feedService.disconnectRealtime();
    };
  }, []);

  const refreshFeed = async (options?: Parameters<typeof feedService.getFeedItems>[0]) => {
    setLoading(true);
    try {
      const result = await fetchFeedItems(1, 50);
      if (result.items.length > 0) {
        setFeedItems(result.items);
        setRealtimeData(result.realtime || {});
      } else {
        setFeedItems([]);
      }
    } catch (error) {
      console.error('Failed to refresh feed:', error);
      setFeedItems([]);
    } finally {
      setLoading(false);
    }
  };

  const recordUserAction = (action: Omit<UserAction, 'id' | 'timestamp'>) => {
    const fullAction: UserAction = {
      ...action,
      id: `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
    };

    return feedService.recordUserAction(fullAction);
  };

  const createAdminHighlight = (highlight: Omit<AdminHighlight, 'id' | 'createdAt'>) => {
    return feedService.createAdminHighlight(highlight);
  };

  const getFeedStats = () => {
    return feedService.getFeedStats();
  };

  const trackActivity = (activity: string, metadata: any = {}) => {
    feedService.trackActivity(activity, metadata);
  };

  const getLiveSessions = () => {
    return feedService.getLiveSessions();
  };

  return {
    feedItems,
    loading,
    realtimeData,
    isConnected,
    refreshFeed,
    recordUserAction,
    createAdminHighlight,
    getFeedStats,
    trackActivity,
    getLiveSessions,
    feedService,
  };
}

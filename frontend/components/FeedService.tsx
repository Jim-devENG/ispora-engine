import { useState, useEffect, useContext, createContext, useRef } from 'react';
// Removed projectAPI and feedAPI imports - now using Supabase queries directly

// Removed demo data arrays - feed now only uses data from backend API
// const realProjects = [ ... ] - REMOVED
// const realOpportunities = [ ... ] - REMOVED

// Legacy demo data arrays (not used - kept for reference only)
const realProjects = [];

// Feed item types that can be auto-generated from user actions
export interface FeedItem {
  id: string;
  type: 'project' | 'campaign' | 'opportunity' | 'milestone' | 'success_story' | 'funding_success' | 'live_event' | 'workroom_live' | 'project_closing' | 'admin_highlight' | 'achievement' | 'certification' | 'collaboration';
  title: string;
  description?: string;
  timestamp: string;
  likes: number;
  location: string;
  category: string;
  urgent?: boolean;
  deadline?: string;
  isLive?: boolean;
  isPinned?: boolean;
  isAdminCurated?: boolean;
  authorId: string;
  authorName: string;
  authorAvatar?: string;
  projectId?: string;
  campaignId?: string;
  opportunityId?: string;
  metadata?: Record<string, any>;
  visibility: 'public' | 'authenticated' | 'private';
  significance: 'low' | 'medium' | 'high' | 'critical';
  isAutoGenerated?: boolean;
}

// User actions that trigger automatic feed generation
export interface UserAction {
  id: string;
  userId: string;
  userName: string;
  userAvatar?: string;
  userLocation?: string;
  actionType: 'project_created' | 'project_joined' | 'project_completed' | 'campaign_launched' | 'campaign_joined' | 'milestone_achieved' | 'opportunity_posted' | 'opportunity_applied' | 'funding_received' | 'session_started' | 'session_completed' | 'certification_earned' | 'achievement_unlocked' | 'collaboration_started' | 'mentor_match' | 'workspace_created';
  entityId: string;
  entityType: 'project' | 'campaign' | 'opportunity' | 'session' | 'certification' | 'achievement' | 'workspace' | 'collaboration';
  entityTitle: string;
  entityCategory: string;
  timestamp: string;
  metadata?: Record<string, any>;
  visibility?: 'public' | 'authenticated' | 'private';
}

// Admin highlights for curation
export interface AdminHighlight {
  id: string;
  type: 'top_mentor' | 'spotlighted_opportunity' | 'impact_stat' | 'featured_project' | 'announcement' | 'success_spotlight' | 'community_milestone';
  title: string;
  description: string;
  image?: string;
  ctaText?: string;
  ctaLink?: string;
  isPinned: boolean;
  expiresAt?: string;
  createdBy: string;
  createdAt: string;
  visibility: 'public' | 'authenticated';
  projectId?: string;
  opportunityId?: string;
}

// Significance level mapping for auto-generation
const SIGNIFICANCE_MAP: Record<string, 'low' | 'medium' | 'high' | 'critical'> = {
  'project_created': 'high',
  'project_joined': 'low',
  'project_completed': 'high',
  'campaign_launched': 'high',
  'campaign_joined': 'low',
  'milestone_achieved': 'medium',
  'opportunity_posted': 'medium',
  'opportunity_applied': 'low',
  'funding_received': 'critical',
  'session_started': 'medium',
  'session_completed': 'low',
  'certification_earned': 'medium',
  'achievement_unlocked': 'medium',
  'collaboration_started': 'medium',
  'mentor_match': 'low',
  'workspace_created': 'low',
};

export class FeedService {
  private static instance: FeedService;
  private feedItems: FeedItem[] = [];
  private adminHighlights: AdminHighlight[] = [];
  private userActions: UserAction[] = [];
  private subscribers: Array<() => void> = [];
  private isLoading = false;
  private lastFetchTime = 0;
  private fetchTimeout = 60000; // 1 minute between fetches

  public static getInstance(): FeedService {
    if (!FeedService.instance) {
      FeedService.instance = new FeedService();
    }
    return FeedService.instance;
  }

  // Subscribe to feed updates
  public subscribe(callback: () => void): () => void {
    this.subscribers.push(callback);
    return () => {
      this.subscribers = this.subscribers.filter(sub => sub !== callback);
    };
  }

  private notifySubscribers(): void {
    this.subscribers.forEach(callback => callback());
  }

  // Track user actions and generate feed items
  public trackUserAction(action: UserAction): void {
    this.userActions.push(action);
    
    // Generate feed item from user action
    const feedItem = this.generateFeedItemFromAction(action);
    if (feedItem) {
      this.feedItems.unshift(feedItem); // Add to beginning of feed
      this.notifySubscribers();
    }
  }

  // Generate feed item from user action
  private generateFeedItemFromAction(action: UserAction): FeedItem | null {
    const significance = SIGNIFICANCE_MAP[action.actionType] || 'low';
    
    switch (action.actionType) {
      case 'milestone_achieved':
        return {
          id: `feed_milestone_${action.entityId}_${Date.now()}`,
          type: 'milestone',
          title: `Milestone Achieved: ${action.entityTitle}`,
          description: action.metadata?.milestoneDescription || `Milestone completed in ${action.entityCategory} project`,
          timestamp: this.formatTimestamp(new Date(action.timestamp)),
          likes: Math.floor(Math.random() * 50) + 10,
          location: action.userLocation || 'Global',
          category: action.entityCategory,
          urgent: false,
          isLive: false,
          isPinned: false,
          isAdminCurated: false,
          authorId: action.userId,
          authorName: action.userName,
          authorAvatar: action.userAvatar,
          projectId: action.metadata?.projectId,
          metadata: {
            milestoneId: action.entityId,
            projectTitle: action.metadata?.projectTitle,
            progress: action.metadata?.progress,
            dueDate: action.metadata?.dueDate,
            ...action.metadata
          },
          visibility: action.visibility || 'public',
          significance,
          isAutoGenerated: true
        };
      
      default:
        return null;
    }
  }

  // Generate feed items from projects (fetched from API)
  private async generateProjectFeedItems(): Promise<FeedItem[]> {
    const projectFeedItems: FeedItem[] = [];

    try {
      // Fetch projects from Supabase - only use real projects, no fallback to demo data
      let apiProjects: any[] = [];
      try {
        // Check if Supabase is configured first
        const { isSupabaseConfigured } = await import('../src/utils/supabaseClient');
        if (!isSupabaseConfigured) {
          console.warn('Supabase not configured, skipping project feed generation');
          return [];
        }

        // Add timeout to prevent hanging
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Project fetch timeout')), 5000)
        );

        const { getProjects } = await import('../src/utils/supabaseQueries');
        const projectsPromise = getProjects();
        apiProjects = await Promise.race([projectsPromise, timeoutPromise]) as any[];
      } catch (supabaseError) {
        // Don't fallback to legacy API - just return empty array
        console.warn('Failed to fetch projects from Supabase:', supabaseError);
        return [];
      }
      
      // Only generate feed items if we have API projects
      if (!apiProjects || apiProjects.length === 0) {
        return [];
      }

      apiProjects.forEach((project: any) => {
      // Create project creation feed item
        const creationDate = new Date(project.startDate || project.createdAt);
      
        // Show all projects from API (no date filter - these are real projects)
        projectFeedItems.push({
          id: `feed_project_${project.id}`,
          type: 'project',
          title: `New Project: ${project.title}`,
          description: project.description,
          timestamp: this.formatTimestamp(creationDate),
          likes: Math.floor(Math.random() * 100) + 20,
          location: project.location || project.university || 'Global', // Use university if location is empty
          category: project.category || project.projectType || 'General',
          urgent: !!(project.status === 'still-open' && project.deadline && this.isDeadlineUrgent(project.deadline)),
          deadline: project.deadline ? this.formatDeadline(project.deadline) : undefined,
          isLive: false,
          isPinned: false,
          isAdminCurated: false,
          authorId: project.authorId,
          authorName: project.authorName,
          authorAvatar: (project.team?.[0] as any)?.avatar, // Added optional chaining
          projectId: project.id,
          metadata: {
            university: project.university,
            tags: project.tags,
            aspiraCategory: project.aspiraCategory,
            team: project.team
          },
          visibility: 'public',
          significance: project.status === 'active' ? 'high' : 'medium',
          isAutoGenerated: true,
        });

      // Create milestone for closed projects
      if (project.status === 'closed' && project.closedDate) {
        const closedDate = new Date(project.closedDate);
        const closedDaysAgo = Math.floor((Date.now() - closedDate.getTime()) / (1000 * 60 * 60 * 24));
        
        if (closedDaysAgo <= 7) { // Show recently closed projects
          projectFeedItems.push({
            id: `feed_project_closed_${project.id}`,
            type: 'success_story',
            title: `Project Completed: ${project.title}`,
              description: `Successfully completed ${project.aspiraCategory?.replace('-', ' ') || 'project'} project in ${project.category}`,
            timestamp: this.formatTimestamp(closedDate),
            likes: Math.floor(Math.random() * 150) + 50,
            location: project.location,
            category: project.category,
            urgent: false,
            isLive: false,
            isPinned: false,
            isAdminCurated: false,
            authorId: project.authorId,
            authorName: project.authorName,
              authorAvatar: (project.team?.[0] as any)?.avatar,
            projectId: project.id,
            metadata: {
              completionDate: project.closedDate,
              university: project.university,
              tags: project.tags
            },
            visibility: 'public',
            significance: 'high',
            isAutoGenerated: true,
          });
        }
      }
    });

    return projectFeedItems;
    } catch (error) {
      console.error('Error fetching projects for feed:', error);
      // Don't use demo data - return empty array if API fails
      return [];
    }
  }

  // Generate feed items from opportunities (currently using demo data, but should fetch from API)
  private generateOpportunityFeedItems(): FeedItem[] {
    const opportunityFeedItems: FeedItem[] = [];

    // TODO: Fetch opportunities from API instead of using demo data
    // For now, return empty array to remove demo data
    // This removes all demo opportunity data from the feed
    return [];
    
    /* Commented out demo data - uncomment when API is ready
    realOpportunities.forEach(opportunity => {
      const postedDate = new Date(opportunity.postedDate);
      const daysAgo = Math.floor((Date.now() - postedDate.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysAgo <= 14) { // Show opportunities posted in last 2 weeks
        opportunityFeedItems.push({
          id: `feed_opportunity_${opportunity.id}`,
          type: 'opportunity',
          title: `New Opportunity: ${opportunity.title}`,
          description: opportunity.description,
          timestamp: this.formatTimestamp(postedDate),
          likes: Math.floor(Math.random() * 80) + 15,
          location: opportunity.location,
          category: opportunity.category,
          urgent: !!(opportunity.urgent || (opportunity.deadline && this.isDeadlineUrgent(opportunity.deadline))),
          deadline: opportunity.deadline ? this.formatDeadline(opportunity.deadline) : undefined,
          isLive: false,
          isPinned: opportunity.featured,
          isAdminCurated: opportunity.featured,
          authorId: opportunity.authorId,
          authorName: opportunity.authorName,
          authorAvatar: opportunity.postedBy.avatar,
          opportunityId: opportunity.id,
          metadata: {
            type: opportunity.type,
            company: opportunity.company,
            remote: opportunity.remote,
            amount: opportunity.amount,
            tags: opportunity.tags,
            applicants: opportunity.applicants,
            experienceLevel: opportunity.experienceLevel
          },
          visibility: 'public',
          significance: opportunity.featured ? 'high' : opportunity.urgent ? 'critical' : 'medium',
          isAutoGenerated: true,
        });
      }
    });

    return opportunityFeedItems;
    */
  }

  // Helper function to check if deadline is urgent (within 7 days)
  private isDeadlineUrgent(deadline: string): boolean {
    const deadlineDate = new Date(deadline);
    const now = new Date();
    const diffDays = Math.ceil((deadlineDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    return diffDays <= 7 && diffDays > 0;
  }

  // Helper function to format deadline for display
  private formatDeadline(deadline: string): string {
    const deadlineDate = new Date(deadline);
    const now = new Date();
    const diffDays = Math.ceil((deadlineDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    
    if (diffDays <= 0) return 'Deadline passed';
    if (diffDays === 1) return 'Due tomorrow';
    if (diffDays <= 7) return `Due in ${diffDays} days`;
    
    // Format as DD/MM/YYYY
    const day = deadlineDate.getDate().toString().padStart(2, '0');
    const month = (deadlineDate.getMonth() + 1).toString().padStart(2, '0');
    const year = deadlineDate.getFullYear();
    return `Due ${day}/${month}/${year}`;
  }

  // Helper function to format timestamp
  private formatTimestamp(date: Date): string {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMinutes = Math.floor(diffMs / (1000 * 60));

    if (diffMinutes < 60) {
      return diffMinutes <= 1 ? 'just now' : `${diffMinutes}m ago`;
    } else if (diffHours < 24) {
      return `${diffHours}h ago`;
    } else if (diffDays === 1) {
      return 'yesterday';
    } else if (diffDays < 7) {
      return `${diffDays}d ago`;
    } else {
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
  }

  // Record a user action and automatically generate feed item
  public recordUserAction(action: UserAction): FeedItem | null {
    this.userActions.push(action);
    
    const feedItem = this.generateFeedItemFromAction(action);
    if (feedItem) {
      this.addFeedItem(feedItem);
      this.notifySubscribers();
      return feedItem;
    }
    
    return null;
  }


  private getActionFeedType(actionType: string): FeedItem['type'] {
    switch (actionType) {
      case 'project_created': return 'project';
      case 'campaign_launched': return 'campaign';
      case 'opportunity_posted': return 'opportunity';
      case 'project_completed': return 'success_story';
      case 'milestone_achieved': return 'milestone';
      case 'funding_received': return 'funding_success';
      case 'session_started': return 'live_event';
      case 'session_completed': return 'workroom_live';
      case 'certification_earned': return 'certification';
      case 'achievement_unlocked': return 'achievement';
      case 'collaboration_started': return 'collaboration';
      default: return 'milestone';
    }
  }

  private getActionTitle(action: UserAction): string {
    switch (action.actionType) {
      case 'project_created': return `New Project: ${action.entityTitle}`;
      case 'campaign_launched': return `New Campaign: ${action.entityTitle}`;
      case 'opportunity_posted': return `New Opportunity: ${action.entityTitle}`;
      case 'project_completed': return `Project Completed: ${action.entityTitle}`;
      case 'milestone_achieved': return `Milestone Achieved: ${action.entityTitle}`;
      case 'funding_received': return `Funding Success: ${action.entityTitle}`;
      case 'session_started': return `LIVE: ${action.entityTitle}`;
      case 'session_completed': return `Session Completed: ${action.entityTitle}`;
      case 'certification_earned': return `Certification Earned: ${action.entityTitle}`;
      case 'achievement_unlocked': return `Achievement Unlocked: ${action.entityTitle}`;
      case 'collaboration_started': return `New Collaboration: ${action.entityTitle}`;
      default: return action.entityTitle;
    }
  }

  private getActionDescription(action: UserAction): string {
    switch (action.actionType) {
      case 'project_created': return `${action.userName} has launched "${action.entityTitle}" - Join the mission to create impact in ${action.entityCategory}`;
      case 'campaign_launched': return `${action.userName} is rallying the community around ${action.entityCategory}`;
      case 'opportunity_posted': return `${action.userName} has posted a new opportunity in ${action.entityCategory}`;
      case 'project_completed': return `${action.userName} and team have successfully completed their project in ${action.entityCategory}`;
      case 'milestone_achieved': return `${action.userName} has reached a significant milestone in ${action.entityCategory}`;
      case 'funding_received': return `${action.userName} has secured funding for their ${action.entityCategory} initiative`;
      case 'session_started': return `${action.userName} is hosting a live session on ${action.entityCategory}`;
      case 'session_completed': return `${action.userName} has completed a learning session in ${action.entityCategory}`;
      case 'certification_earned': return `${action.userName} has earned certification in ${action.entityCategory}`;
      case 'achievement_unlocked': return `${action.userName} has unlocked a new achievement in ${action.entityCategory}`;
      case 'collaboration_started': return `${action.userName} has started a new collaboration in ${action.entityCategory}`;
      default: return action.metadata?.description || `New activity in ${action.entityCategory}`;
    }
  }

  // Add feed item directly
  public addFeedItem(item: FeedItem): void {
    this.feedItems.unshift(item); // Add to beginning for chronological order
  }

  // Create admin highlight
  public createAdminHighlight(highlight: Omit<AdminHighlight, 'id' | 'createdAt'>): AdminHighlight {
    const newHighlight: AdminHighlight = {
      ...highlight,
      id: `highlight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString(),
    };
    
    this.adminHighlights.push(newHighlight);
    
    // Convert to feed item
    const feedItem = this.convertHighlightToFeedItem(newHighlight);
    this.addFeedItem(feedItem);
    this.notifySubscribers();
    
    return newHighlight;
  }

  // Convert admin highlight to feed item
  private convertHighlightToFeedItem(highlight: AdminHighlight): FeedItem {
    return {
      id: `admin_${highlight.id}`,
      type: 'admin_highlight',
      title: highlight.title,
      description: highlight.description,
      timestamp: this.formatTimestamp(new Date(highlight.createdAt)),
      likes: Math.floor(Math.random() * 200) + 50,
      location: 'Global',
      category: 'Admin Highlight',
      isPinned: highlight.isPinned,
      isAdminCurated: true,
      authorId: highlight.createdBy,
      authorName: 'Aspora Team',
      authorAvatar: undefined,
      projectId: highlight.projectId,
      opportunityId: highlight.opportunityId,
      metadata: {
        image: highlight.image,
        ctaText: highlight.ctaText,
        ctaLink: highlight.ctaLink,
        highlightType: highlight.type,
        expiresAt: highlight.expiresAt,
      },
      visibility: highlight.visibility,
      significance: 'high',
      isAutoGenerated: false,
    };
  }

  // Get feed items with filtering options
  public async getFeedItems(options: {
    includeAdminHighlights?: boolean;
    userFilter?: string;
    categoryFilter?: string;
    significanceFilter?: 'all' | 'low' | 'medium' | 'high' | 'critical';
    limit?: number;
    visibility?: 'public' | 'authenticated' | 'all';
    includeExpired?: boolean;
    forceRefresh?: boolean;
  } = {}): Promise<FeedItem[]> {
    const { 
      includeAdminHighlights = true, 
      userFilter, 
      categoryFilter,
      significanceFilter = 'all',
      limit, 
      visibility = 'all',
      includeExpired = true,
      forceRefresh = false
    } = options;

    // Prevent too frequent requests
    const now = Date.now();
    if (!forceRefresh && this.isLoading) {
      // Return existing items if already loading
      return this.feedItems;
    }
    if (!forceRefresh && (now - this.lastFetchTime) < this.fetchTimeout) {
      // Return cached items if recently fetched
      return this.feedItems;
    }

    this.isLoading = true;
    this.lastFetchTime = now;

    try {
      // Fetch feed items from Supabase (includes feed items created by backend)
      let apiFeedItems: FeedItem[] = [];
      try {
        // Check if Supabase is configured first
        const { isSupabaseConfigured } = await import('../src/utils/supabaseClient');
        if (!isSupabaseConfigured) {
          console.warn('Supabase not configured, skipping feed fetch');
          apiFeedItems = [];
        } else {
          try {
            // Add timeout to prevent hanging
            const timeoutPromise = new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Feed fetch timeout')), 5000)
            );

            const { getFeedItems } = await import('../src/utils/supabaseQueries');
            const feedPromise = getFeedItems({ limit: 100 });
            apiFeedItems = await Promise.race([feedPromise, timeoutPromise]) as FeedItem[];
            // Only log if there are items or if it's the first fetch
            // Only log in development to reduce console noise
            if (import.meta.env.DEV && apiFeedItems.length > 0) {
              console.log(`Fetched ${apiFeedItems.length} feed items from Supabase`);
            }
          } catch (supabaseError) {
            // Don't fallback to legacy API - just use empty array
            console.warn('Failed to fetch feed items from Supabase:', supabaseError);
            apiFeedItems = [];
          }
        }
      } catch (error) {
        console.warn('Failed to fetch feed items:', error);
        apiFeedItems = [];
      }

      // Always generate feed items from projects (they may not have feed items in DB yet)
      // This ensures projects show up in the feed even if backend didn't create feed items
      let projectFeedItems: FeedItem[] = [];
      let opportunityFeedItems: FeedItem[] = [];
      
      projectFeedItems = await this.generateProjectFeedItems();
      opportunityFeedItems = this.generateOpportunityFeedItems();
      // Only log once per session when items are first generated (not on every fetch)
      // This prevents excessive logging when feed is refreshed frequently
      
      // Combine: API feed items first (most recent/accurate), then generated, then local
      // Remove duplicates by ID (API items take precedence)
      const allGeneratedItems = [...projectFeedItems, ...opportunityFeedItems];
      const generatedItemIds = new Set(allGeneratedItems.map(item => item.id));
      const uniqueGeneratedItems = allGeneratedItems.filter((item, index, self) => 
        index === self.findIndex(i => i.id === item.id)
      );
      
      // Filter out generated items that already exist in API feed items
      const apiFeedItemIds = new Set(apiFeedItems.map(item => item.id));
      const filteredGeneratedItems = uniqueGeneratedItems.filter(item => !apiFeedItemIds.has(item.id));
      
      // Combine: API feed items first (most recent/accurate), then generated
      // Removed this.feedItems to prevent demo data from showing
      // Only use API feed items and generated items from real projects
      let feedItems = [...apiFeedItems, ...filteredGeneratedItems];

      // Filter by visibility
      if (visibility !== 'all') {
        feedItems = feedItems.filter(item => {
          if (visibility === 'public') {
            return item.visibility === 'public';
          }
          return item.visibility === 'public' || item.visibility === 'authenticated';
        });
      }

      // Filter expired highlights
      if (!includeExpired) {
        feedItems = feedItems.filter(item => {
          if (item.isAdminCurated && item.metadata?.expiresAt) {
            return new Date(item.metadata.expiresAt) > new Date();
          }
          return true;
        });
      }

      // Filter admin highlights
      if (!includeAdminHighlights) {
        feedItems = feedItems.filter(item => !item.isAdminCurated);
      }

      // Filter by significance
      if (significanceFilter !== 'all') {
        const significanceLevels = ['low', 'medium', 'high', 'critical'];
        const minLevel = significanceLevels.indexOf(significanceFilter);
        feedItems = feedItems.filter(item => {
          const itemLevel = significanceLevels.indexOf(item.significance);
          return itemLevel >= minLevel;
        });
      }

      // Apply search filters
      if (userFilter) {
        feedItems = feedItems.filter(item => 
          item.authorName?.toLowerCase().includes(userFilter.toLowerCase()) ||
          item.title.toLowerCase().includes(userFilter.toLowerCase()) ||
          item.description?.toLowerCase().includes(userFilter.toLowerCase())
        );
      }

      if (categoryFilter) {
        feedItems = feedItems.filter(item => 
          item.category.toLowerCase().includes(categoryFilter.toLowerCase())
        );
      }

      // Remove duplicates based on ID
      const uniqueItems = feedItems.filter((item, index, self) => 
        index === self.findIndex(t => t.id === item.id)
      );

      // Sort by priority (pinned first, then by timestamp)
      uniqueItems.sort((a, b) => {
        if (a.isPinned && !b.isPinned) return -1;
        if (!a.isPinned && b.isPinned) return 1;
        // Sort by creation time for real projects/opportunities, timestamp for others
        return b.timestamp.localeCompare(a.timestamp);
      });

      // Cache the results
      this.feedItems = uniqueItems;

      // Apply limit
      if (limit) {
        return uniqueItems.slice(0, limit);
      }

      return uniqueItems;
    } finally {
      this.isLoading = false;
    }
  }

  // Get feed statistics
  public async getFeedStats(): Promise<{
    totalItems: number;
    adminHighlights: number;
    userGenerated: number;
    publicItems: number;
    liveEvents: number;
    recentActivity: number;
  }> {
    const allItems = await this.getFeedItems();
    const now = new Date();
    const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    
    return {
      totalItems: allItems.length,
      adminHighlights: allItems.filter(item => item.isAdminCurated).length,
      userGenerated: allItems.filter(item => !item.isAdminCurated).length,
      publicItems: allItems.filter(item => item.visibility === 'public').length,
      liveEvents: allItems.filter(item => item.isLive).length,
      recentActivity: allItems.filter(item => {
        // For items with timestamp strings, parse them
        const itemTime = new Date(item.timestamp);
        return itemTime > last24Hours;
      }).length,
    };
  }

  // Initialize with mock admin highlights for demonstration
  // REMOVED - Feed now only shows data from backend API
  // This method is kept for reference but should not be called
  public initializeMockData(): void {
    // This method has been disabled - feed now only uses backend API data
    // Do not create mock data - all feed items should come from the backend
    console.warn('initializeMockData() called but disabled - feed only uses backend API data');
  }

  // Clear all data (for testing)
  public clearAll(): void {
    this.feedItems = [];
    this.adminHighlights = [];
    this.userActions = [];
    this.notifySubscribers();
  }
}

// React Context for Feed Service
const FeedContext = createContext<FeedService | null>(null);

export function FeedProvider({ children }: { children: React.ReactNode }) {
  const [feedService] = useState(() => {
    const service = FeedService.getInstance();
    // Removed initializeMockData() - feed now only shows data from backend API
    return service;
  });

  return (
    <FeedContext.Provider value={feedService}>
      {children}
    </FeedContext.Provider>
  );
}

// React Hook for using Feed Service
export function useFeedService() {
  const feedService = useContext(FeedContext) || FeedService.getInstance();
  const [feedItems, setFeedItems] = useState<FeedItem[]>([]);
  const [loading, setLoading] = useState(false);
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    let mounted = true;
    let retryCount = 0;
    const MAX_RETRIES = 3;

    // Initialize feed
    const loadFeed = async () => {
      if (!mounted) return;
      
      try {
        setLoading(true);
        const items = await feedService.getFeedItems({ forceRefresh: true });
        if (mounted) {
          setFeedItems(items);
          retryCount = 0; // Reset retry count on success
        }
      } catch (error) {
        console.error('Error loading feed:', error);
        if (mounted) {
          setFeedItems([]); // Set empty array on error
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };
    loadFeed();

    // Subscribe to feed service updates (but prevent infinite retries)
    const unsubscribe = feedService.subscribe(async () => {
      if (!mounted || retryCount >= MAX_RETRIES) return;
      
      try {
        retryCount++;
        const updatedItems = await feedService.getFeedItems();
        if (mounted) {
          setFeedItems(updatedItems);
          retryCount = 0; // Reset on success
        }
      } catch (error) {
        console.error('Error updating feed from subscription:', error);
        // Don't increment retry count here as this is triggered by external events
      }
    });

    // Setup Supabase Realtime for feed updates
    let realtimeChannels: any[] = [];
    const setupRealtime = async (): Promise<void> => {
      try {
        // Check if Supabase is configured first
        const { isSupabaseConfigured } = await import('../src/utils/supabaseClient');
        if (!isSupabaseConfigured) {
          console.warn('Supabase not configured, skipping realtime setup');
          return;
        }

        const { subscribeToFeed } = await import('../src/utils/supabaseRealtime');
        
        const feedChannel = subscribeToFeed({
          onInsert: async (payload) => {
            if (!mounted) return;
            console.log('Real-time feed item added:', payload);
            // Refresh feed to get latest items (but don't force refresh to use cache)
            try {
              const updatedItems = await feedService.getFeedItems();
              if (mounted) {
                setFeedItems(updatedItems);
              }
            } catch (error) {
              console.error('Error refreshing feed after insert:', error);
            }
          },
          onUpdate: async (payload) => {
            if (!mounted) return;
            console.log('Feed item updated:', payload);
            try {
              const updatedItems = await feedService.getFeedItems();
              if (mounted) {
                setFeedItems(updatedItems);
              }
            } catch (error) {
              console.error('Error refreshing feed after update:', error);
            }
          },
          onDelete: async (payload) => {
            if (!mounted) return;
            console.log('Feed item deleted:', payload);
            try {
              const updatedItems = await feedService.getFeedItems();
              if (mounted) {
                setFeedItems(updatedItems);
              }
            } catch (error) {
              console.error('Error refreshing feed after delete:', error);
            }
          },
        });
        
        realtimeChannels.push(feedChannel);
        if (import.meta.env.DEV) {
          console.log('Supabase Realtime connected for feed updates');
        }
      } catch (error) {
        // Don't fallback to polling - just log the error to prevent infinite retries
        if (import.meta.env.DEV) {
          console.warn('Supabase Realtime connection failed:', error);
        }
        // Feed will only update on manual refresh or when user actions trigger updates
      }
    };

    setupRealtime();

    // Listen for project creation events (local events)
    const handleProjectCreated = async () => {
      if (!mounted) return;
      try {
        const updatedItems = await feedService.getFeedItems({ forceRefresh: true });
        if (mounted) {
          setFeedItems(updatedItems);
        }
      } catch (error) {
        console.error('Error refreshing feed after project creation:', error);
      }
    };
    window.addEventListener('projectCreated', handleProjectCreated);

    return () => {
      mounted = false;
      unsubscribe();
      window.removeEventListener('projectCreated', handleProjectCreated);
      
      // Cleanup polling
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
        pollingIntervalRef.current = null;
      }
      
      // Cleanup Supabase Realtime channels
      if (realtimeChannels.length > 0) {
        import('../src/utils/supabaseRealtime').then(({ unsubscribeAll }) => {
          unsubscribeAll(realtimeChannels);
          realtimeChannels = [];
        }).catch(() => {
          // Ignore errors during cleanup
        });
      }
    };
  }, [feedService]);

  const refreshFeed = async (options?: Parameters<typeof feedService.getFeedItems>[0]) => {
    setLoading(true);
    try {
      const items = await feedService.getFeedItems(options);
      setFeedItems(items);
    } finally {
      setLoading(false);
    }
  };

  const recordUserAction = (action: Omit<UserAction, 'id' | 'timestamp'>) => {
    const fullAction: UserAction = {
      ...action,
      id: `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
    };
    
    return feedService.recordUserAction(fullAction);
  };

  const createAdminHighlight = (highlight: Omit<AdminHighlight, 'id' | 'createdAt'>) => {
    return feedService.createAdminHighlight(highlight);
  };

  const getFeedStats = async () => {
    return await feedService.getFeedStats();
  };

  return {
    feedItems,
    loading,
    refreshFeed,
    recordUserAction,
    createAdminHighlight,
    getFeedStats,
    feedService,
  };
}